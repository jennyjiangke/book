[["index.html", "Media Analytics With R Preface", " Media Analytics With R Jenny Jiang &amp; Brian Walsh 2022-08-19 Preface The rapid development of information technology, along with the emergence of big data in the field of digital media, projects a workforce shortage for data-driven positions. In particular, the ability to use statistics to analyze and interpret the data obtained from tracking user interactions on websites and social media platforms make Communications students stand out in competitive job markets from a variety of industries. However, the integration of analytics into universities’ communication programs and curricula (e.g., Journalism, Television and Cinema, Public Relations, Strategic Communications, Communication Design, Health Communication, Sports Communication, Environmental Communication) is yet to catch up to the industry’s new demands. To address this need, this book introduces Communication students to R, which is a free software environment for statistical computing and graphics, to measure and analyze audiences’ digital footprints, employ data-driven problem solving to gauge audience engagement, formulate insights, plan and execute strategies, and evaluate outcomes. "],["intro-to-r-load-filter-plot-babynames.html", "Chapter 1 Intro to R: Load, Filter &amp; Plot: Babynames 1.1 Loading Packages and Data 1.2 Filtering Data 1.3 Visualizing 1.4 Modifying Data 1.5 Review 1.6 Mutate", " Chapter 1 Intro to R: Load, Filter &amp; Plot: Babynames 1.1 Loading Packages and Data The U.S. Social Security Administration keeps records on first names at birth, going back to 1890. Data Scientist and R Superstar Hadley Wickham has created an R package that lets us load this data directly into R. Using a package is a two-step process: first, you install the package onto your computer; secondly, you load the package as a library to access its functions and data in your current work environment. Put another way, a package needs only be installed once, but has to be loaded into your R environment every time you start up R Studio. install.packages(&#39;babynames&#39;) library(babynames) Where do these packages come from, and who makes them? Why? By default, packages are hosted on an online repository referred to as CRAN; they can also be installed from GitHub. And anyone can make and share an R package, for instance if they solve a complicated workflow and want to share that insight with others to save them time and redundancy. Having R package-based means that users only need to load packages relevant to their area of study - keep in mind R is used for everything from Health Sciences to Comparative Literature. Let’s take a look at the babynames package, by asking about its structure, and taking a glimpse at it: str(babynames) ## tibble [1,924,665 × 5] (S3: tbl_df/tbl/data.frame) ## $ year: num [1:1924665] 1880 1880 1880 1880 1880 1880 1880 1880 1880 1880 ... ## $ sex : chr [1:1924665] &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; ... ## $ name: chr [1:1924665] &quot;Mary&quot; &quot;Anna&quot; &quot;Emma&quot; &quot;Elizabeth&quot; ... ## $ n : int [1:1924665] 7065 2604 2003 1939 1746 1578 1472 1414 1320 1288 ... ## $ prop: num [1:1924665] 0.0724 0.0267 0.0205 0.0199 0.0179 ... glimpse(babynames) ## Rows: 1,924,665 ## Columns: 5 ## $ year &lt;dbl&gt; 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 1880, 188… ## $ sex &lt;chr&gt; &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, … ## $ name &lt;chr&gt; &quot;Mary&quot;, &quot;Anna&quot;, &quot;Emma&quot;, &quot;Elizabeth&quot;, &quot;Minnie&quot;, &quot;Margaret&quot;, &quot;Ida&quot;, &quot;Alice&quot;, &quot;Bertha&quot;, &quot;Sarah&quot;, &quot;Annie&quot;, &quot;C… ## $ n &lt;int&gt; 7065, 2604, 2003, 1939, 1746, 1578, 1472, 1414, 1320, 1288, 1258, 1226, 1156, 1063, 1045, 1040, 1012, 995… ## $ prop &lt;dbl&gt; 0.07238359, 0.02667896, 0.02052149, 0.01986579, 0.01788843, 0.01616720, 0.01508119, 0.01448696, 0.0135239… The output of glimpse is a little overwhelming at first, although it makes clear there are a lot of rows in it (Excel cannot handle 1,924,665 rows of data, but this is still not ‘Big Data’). So let’s try head and tail to see the first and last 10 rows of the dataset: head(babynames) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F Mary 7065 0.0724 ## 2 1880 F Anna 2604 0.0267 ## 3 1880 F Emma 2003 0.0205 ## 4 1880 F Elizabeth 1939 0.0199 ## 5 1880 F Minnie 1746 0.0179 ## 6 1880 F Margaret 1578 0.0162 tail(babynames) ## # A tibble: 6 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2017 M Zyhier 5 0.00000255 ## 2 2017 M Zykai 5 0.00000255 ## 3 2017 M Zykeem 5 0.00000255 ## 4 2017 M Zylin 5 0.00000255 ## 5 2017 M Zylis 5 0.00000255 ## 6 2017 M Zyrie 5 0.00000255 Everything we’ve done up to this point has been in Base R, that is, R without any functions added via packages. Throughout this book, we’ll be relying on a collection of inter-connected packages called the Tidyverse, which drastically simplifies performing varying calculations on data. Like all packages, we first have to install and then load it. • Please note: when you install the ‘tidyverse’ package, you’ll get a prompt inside your R Console at the bottom-left, asking you a Yes/No question. You cannot proceed until you click your cursor in the Console and type out the word ‘Yes.’ Note that the Console may be cut off or obfuscated; you may need to adjust your R Studio windows to see it better. install.packages(&#39;tidyverse&#39;) library(tidyverse) Loading the Tidyverse shows the eight packages that make it up, as well as a few warnings that we can disregard. We’ll begin on focusing on three packages that will help us work with babynames: dplyr, ggplot2 and stringr. All three are loaded once we run the library(tidyverse) command. The first, dplyr, we use to manipulate data: to filter it, rearrange it,count it, do calculations for custom columns, and pivot the data to our liking. 1.1.1 %&gt;% The greatest and most powerful functionality added to R via the Tidyverse, in my opinion, is the ‘pipe operator:’ %&gt;% …which allows us to chain commands to each other. It can be tricky to type; the shortcut is Shift-Command-M (on a PC, it’d be Shift-Control-M). Another useful logical operator for this dataset is the ‘includes’ operator, which looks like this: %in% . I think an example will make the best sense of how to use these operators, so let’s get started with filtering. 1.2 Filtering Data If we just type ‘babynames’ in R, we’ll see the first 10 rows of data, organized by year, and an indication that there are nearly 2 million more rows remaining. That’s way too much to visualize! Let’s start by filtering for specific names: I’ll use the names of The Beatles as a starting point. babynames %&gt;% filter(name %in% &#39;Ringo&#39;) ## # A tibble: 28 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1964 M Ringo 12 0.00000592 ## 2 1965 M Ringo 18 0.0000095 ## 3 1966 M Ringo 8 0.0000044 ## 4 1972 M Ringo 6 0.00000358 ## 5 1974 M Ringo 6 0.00000368 ## 6 1975 M Ringo 8 0.00000493 ## 7 1976 M Ringo 13 0.00000796 ## 8 1977 M Ringo 10 0.00000585 ## 9 1978 M Ringo 12 0.00000702 ## 10 1979 M Ringo 9 0.00000502 ## # … with 18 more rows That ‘translates’ to ‘take the babynames dataset and filter it so only values in the name column that match ’Ringo’ are included.’ The and is the pipe operator ( %&gt;% ), and the match is the %in% operator. If we wanted to look for more than one name, we’d change the syntax to use a ‘combine’ command ( c ), with the values comma-separated. Let’s try that with babynames and the Beatles. babynames %&gt;% filter(name %in% c(&#39;Ringo&#39;, &#39;Paul&#39;, &#39;George&#39;, &#39;John&#39;)) ## # A tibble: 831 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1880 F John 46 0.000471 ## 2 1880 F George 26 0.000266 ## 3 1880 M John 9655 0.0815 ## 4 1880 M George 5126 0.0433 ## 5 1880 M Paul 301 0.00254 ## 6 1881 F George 30 0.000303 ## 7 1881 F John 26 0.000263 ## 8 1881 M John 8769 0.0810 ## 9 1881 M George 4664 0.0431 ## 10 1881 M Paul 291 0.00269 ## # … with 821 more rows Now we get a ton of results - far too many to show on the screen. 1.3 Visualizing That’s where data visualization comes in: it’s often impossible to even see your results from big data without plotting it into a visual, summarized form. Our visualization package is called ggplot2, and it’s amazingly straightforward to use, once you get used to its syntax: ggplot(data, aes(x,y)) + geometry() Huh? Well, our function (think: verb) is ‘ggplot().’ Inside that, we define our ‘aesthetics’ (aes) for the visualization, which has its own set of parentheses. Inside the aesthetics, we define the columns we want to use for the x and y axes, and finally we define the type of geomtry our visualization will use, such as a bar chart ( geom_col() ), scatterplot ( geom_point() ), or line chart ( geom_line() ), for instance. Like most things in R and the Tidyverse, it’s easier to make sense of ggplot() through examples: babynames %&gt;% filter(name %in% &#39;Ringo&#39;) %&gt;% ggplot(aes(year, prop)) + geom_line() To review, we take ‘babynames,’ and filter so the name includes ‘Ringo;’ We then plot by setting the aesthetics to use the ‘year’ and ‘prop’ columns of our dataset; our plot will be a line chart. Learning by example often raises as many questions as it answers, so I’ll try to address those as we go along. Let’s take this one step further: babynames %&gt;% filter(name %in% c(&#39;Ringo&#39;, &#39;John&#39;, &#39;George&#39;, &#39;Paul&#39;)) %&gt;% ggplot(aes(year, prop, color = name)) + geom_line() That looks really weird! Why? In summary, becuase there is a ‘Sex’ column in the data. So, for any year - say, 1974 - there are 4 male Ringo’s, and zero female Ringo’s - ggplot is trying to plot both the 4 and 0 values on the same vertical axis. Therefore, our solution is to filter out one sex: babynames %&gt;% filter(name %in% c(&#39;Ringo&#39;, &#39;John&#39;, &#39;George&#39;, &#39;Paul&#39;)) %&gt;% filter(sex %in% &quot;M&quot;) %&gt;% ggplot(aes(year, prop, color = name)) + geom_line() That’s much better - but what happened to Ringo? The other names are so much more popular that his: he doesn’t show up until 1964, and the proportion of people born per year with that name is very low in comparison to, say, ‘George.’ Let’s try filtering the ‘year’ column in order to have our ggplot ‘zoom in’ on the Ringo section. babynames %&gt;% filter(name %in% c(&#39;Ringo&#39;, &#39;John&#39;, &#39;George&#39;, &#39;Paul&#39;)) %&gt;% filter(sex %in% &quot;M&quot;) %&gt;% filter(year &gt; 1964) %&gt;% ggplot(aes(year, prop, color = name)) + geom_line() This visualization is more limited, but somewhat more equitable - it starts around the time the Beatles became popular, but ignores the previous popularity of some of the names (John, Paul, George). Another question arises: why are we plotting ‘prop?’ what about ‘n?’ babynames %&gt;% filter(name %in% c(&#39;Ringo&#39;, &#39;John&#39;, &#39;George&#39;, &#39;Paul&#39;)) %&gt;% filter(sex %in% &quot;M&quot;) %&gt;% filter(year &gt; 1964) %&gt;% ggplot(aes(year, n, color = name)) + geom_line() The results are very similar for ‘n’ as they were for ‘prop.’ Let’s take an example name where that’s not the case: babynames %&gt;% filter(name %in% &quot;Mary&quot;) %&gt;% filter(sex %in% &quot;M&quot;) %&gt;% filter(year &lt; &#39;1940&#39;) %&gt;% ggplot(aes(year, prop)) + geom_line() babynames %&gt;% filter(name %in% &quot;Mary&quot;) %&gt;% filter(sex %in% &quot;M&quot;) %&gt;% filter(year &lt; &#39;1940&#39;) %&gt;% ggplot(aes(year, n)) + geom_line() # you can also try &#39;Joseph&#39; and &#39;M&#39; Note that n is a simple count of names per year, whereas prop is a calculation: total number of people given that number in a given year, divided by the total number of births. So when there are fewer names in the database, the difference between n and prop is more obvious. That’d be in the early years of the babynames dataset, when biblical names like Mary and Joseph were much more common relative to all of the names. Since then, there are just more names, meaning the prop of the most common names of long ago have nearly all gone down in prop - even if their n value is increasing. # note that we have not learned how to do this yet: babynames %&gt;% group_by(year) %&gt;% summarize(total = n_distinct(name)) %&gt;% ggplot(aes(year, total)) + geom_line() + xlab(&#39;Year&#39;) + ylab(&#39;Count of Unique Names&#39;) Now that we have all of this information, we can try to answer specific questions. Let’s start with some basic ones - try to answer them on your own if you can. What was the most popular name in the first year of the database, 1890? babynames %&gt;% filter(year == &quot;1890&quot;) ## # A tibble: 2,695 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1890 F Mary 12078 0.0599 ## 2 1890 F Anna 5233 0.0259 ## 3 1890 F Elizabeth 3112 0.0154 ## 4 1890 F Margaret 3100 0.0154 ## 5 1890 F Emma 2980 0.0148 ## 6 1890 F Florence 2744 0.0136 ## 7 1890 F Ethel 2718 0.0135 ## 8 1890 F Minnie 2650 0.0131 ## 9 1890 F Clara 2496 0.0124 ## 10 1890 F Bertha 2388 0.0118 ## # … with 2,685 more rows But then what? Any why two ‘=’ symbols? 1.3.1 Syntax Let’s start with ‘==.’ In R, you can create variables, and one way to do this is with a single ‘=’ symbol: x = 10 In the case of babynames, we’re not aiming to create a variable - we just want to limit the data to only include entries in the year 1890 - so we need to use two ‘=’ symbols to differentiate from making a variable. Two ‘=’ symbols tests to see if values are equal. Also, in this textbook we will be using the arrow function to create variables, because it works in two directions: x &lt;- 10 10 -&gt; x Way more useful than ‘=.’ So, to review, we’ll use the arrow -&gt; operator in lieu of the ‘=’ symbol, but we’ll still use ‘==’ in order to filter our data based on specific conditions, like the year equals 1890. 1.3.2 Creating Variables Let’s take the entire babynames dataset and create a sub-set of the data that only incudes entries from the year 1890, using a variable: babynames %&gt;% filter(year == &quot;1890&quot;) -&gt; babynames_1890 Note that all of our variables, or columns, are lowercase - everything is, except the babynames themselves. R will not detect your mistake if you lowercase a name or Uppercase a Column. Now we have a variable equal to a subset of our data, and we can see its contents by typing its name: babynames_1890. That makes things much easier, if that’s the only year we want to look at - but we’ll have to plot our graphs differently. 1.4 Modifying Data Let’s begin with the arrange() function, which does as it sounds - we’ll tell it to arrange in descending order of prop: babynames_1890 %&gt;% arrange(desc(prop)) ## # A tibble: 2,695 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1890 M John 8502 0.0710 ## 2 1890 M William 7494 0.0626 ## 3 1890 F Mary 12078 0.0599 ## 4 1890 M James 5097 0.0426 ## 5 1890 M George 4458 0.0372 ## 6 1890 M Charles 4061 0.0339 ## 7 1890 F Anna 5233 0.0259 ## 8 1890 M Frank 3078 0.0257 ## 9 1890 M Joseph 2670 0.0223 ## 10 1890 M Robert 2541 0.0212 ## # … with 2,685 more rows So, what was the answer to our question? Well, ‘John’ has the highest proportion, but Mary has the highest count. Why does Mary have a higher ‘n’ value, but a lower proportion - in the same year? Because ‘prop’ also takes sex into account, i.e. it counts the proportion of each sex in each year that receives a given name. Let’s account for this somewhat confusing aspect to our data by splitting it up along the variable that is giving us a hard time: sex. But sex is the least of our problems, as we’ll see. 1.4.1 Count Let’s try by using a new function, count(), which does exactly what it sounds like. We can specify to sort the results; for some archaic reason, we have to write the words ‘true’ and ‘false’ in ALL CAPS: babynames_1890 %&gt;% count(sex, sort = TRUE) ## # A tibble: 2 × 2 ## sex n ## &lt;chr&gt; &lt;int&gt; ## 1 F 1534 ## 2 M 1161 That’s not very many names - less than 3,000 unique names in the U.S. in 1890. It’s also notable there are more female names than male - not more women, just more variety in the names for females births. count() can be helpful, but note that it strips away all of the columns except the one we counted - and adds an ‘n’ column. But that’s it - prop, count, name, year - all gone. More on count(later). Let’s plot the most popular names of 1890 - but first, we have to cut them off, as 2,695 names is too many to plot: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) ## # A tibble: 10 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1890 M John 8502 0.0710 ## 2 1890 M William 7494 0.0626 ## 3 1890 F Mary 12078 0.0599 ## 4 1890 M James 5097 0.0426 ## 5 1890 M George 4458 0.0372 ## 6 1890 M Charles 4061 0.0339 ## 7 1890 F Anna 5233 0.0259 ## 8 1890 M Frank 3078 0.0257 ## 9 1890 M Joseph 2670 0.0223 ## 10 1890 M Robert 2541 0.0212 We can plot ten names, easy: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(name, prop)) + geom_col() As a reminder, in ggplot() we define our aesthetics by specifying which columns will create the x- and y-axes. We then indicate the type of graph we want to make - in this case a column chart. Why not a line chart like before? Because line charts only work with continous variables, like year. In this case, we are only plotting the data from one year, so year is no longer something we can plot. We are plotting name and prop, which are discrete variables. What’s the difference? To oversimplify, discrete variables can be counted - how many Steve’s show up in babynames, for instance - and continuous variables are measured, like years, as well as temperature, wind speed, etc. So what is prop? Prop is a calculated variable, in that it’s the result of an equation: the total number of births of a particular gender in a specific year, divided by the total number of instances of a particular name. In other words, we’re counting things. So it’s a discrete variable. We would make a line chart [ geom_line() ] when using a continuous variable, like year, as we did with the Beatles. In this case, plotting name and prop will make the most sense in a column chart (we usually call these bar charts, but ggplot’s bar charts are a little trickier to plot than column charts, and we’re aiming for easiness right now). Looking back at our chart’s results, I would prefer the results in order or prop. Why didn’t arrange(desc(prop)) do that for us? Well, long story, but basically, regardless of how you reshape your data, ggplot() is going to need its own set of instructions for how to visualize it in a particular order. So arrange() doesn’t work - we have to make the adjustment inside the ggplot() call: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop), prop)) + geom_col() OK, that got pretty complicated. Three nested parentheses? Let’s look at the offending line: originally, the ‘aesthetics’ of our ggplot() were: aes(name, prop) And we want to reorder the ‘names,’ based on ‘prop:’ reorder(name, prop) In other words, italics ‘I want to reorder the names based on their proportion.’ Let’s put it back together: aes(reorder(name, prop), prop)) And to see it in action: babynames_1890 %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop), prop)) + geom_col() OK, but why is it in the wrong order? We just have to ‘tell’ ggplot() to reverse, or do the opposite of, the order it chose. We can use the minus sign for this: babynames_1890 %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, -prop), prop)) + geom_col() 1.4.2 More Aesthetics Let’s add some color: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, -prop), prop, color = &quot;red&quot;)) + geom_col() That didn’t work the way it did for The Beatles! Of course, that was a line graph - geom_line() - and that line has a color. This time, ‘color’ is read as stroke or outline; fill controls our columns. Also, we need to move the fill command to inside the geometry: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, -prop), prop)) + geom_col(fill = &quot;blue&quot;) Great. Now let’s make the fill based on the value of a column: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, -prop), prop, fill = name)) + geom_col() OK, great. The names are all different colors because they are discrete data points, i.e. they are not measured - like ‘prop:’ We did this by setting our fill color to a variable - in this case, name. Since ‘prop’ is measured, or discrete, it is visualized as a range of a single color. This would all look better sideways: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop), prop, fill = prop)) + geom_col() + coord_flip() That last line, connected to the geometry with a ‘+’ symbol, tells ggplot to flip the coordinates of our plot 90 degrees. By the way, we could ‘show’ the anomaly about John and Mary having confusing ‘n’ and ‘prop’ values by adjusting our aesthetics - let’s use fill: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop), prop, fill = n)) + geom_col() + coord_flip() We’d mentioned earlier that the ‘sex’ column is complicating our use of ‘prop’ over ‘n.’ To account for this problem, we could color by sex: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop), prop, fill = sex)) + geom_col() + coord_flip() One more ggplot() trick to change the way we visualize our data: making multiple graphs, based on a variable: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop), prop, fill = sex)) + geom_col() + coord_flip() + facet_wrap(~sex) What facet_wrap is trying to do is create multiple graphs based on one variable - in this case, Sex. That looks…. terrible. Why? The function facet_wrap() is trying to use the same values, and the same scale, for each of the two graphs. Let’s ‘free’ the y-axis to account for this discrepancy: babynames_1890 %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop), prop, fill = sex)) + geom_col() + coord_flip() + facet_wrap(~sex, scales = &quot;free_y&quot;) Wow, that really changes things - weren’t there more female than male names, when we used count() earlier? Sure, but while there may be more variance in female names in 1890, females only have two of the most common names. 1.5 Review OK, so now we can answer some other direct questions: What were the most popular names in 2017, the most recent year of the database?&lt; /li&gt; How would we answer this? I find it’s easiest to write our the process in English, then translate it to R and the Tidyverse: ‘Take babynames and filter it to only include entries from 2017. Then arrange the remaining entries in descending order of proportion.’ In the Tidyverse: babynames %&gt;% filter(year == 2017) %&gt;% arrange(desc(prop)) ## # A tibble: 32,469 × 5 ## year sex name n prop ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2017 F Emma 19738 0.0105 ## 2 2017 F Olivia 18632 0.00994 ## 3 2017 M Liam 18728 0.00954 ## 4 2017 M Noah 18326 0.00933 ## 5 2017 F Ava 15902 0.00848 ## 6 2017 F Isabella 15100 0.00805 ## 7 2017 F Sophia 14831 0.00791 ## 8 2017 M William 14904 0.00759 ## 9 2017 M James 14232 0.00725 ## 10 2017 F Mia 13437 0.00717 ## # … with 32,459 more rows It looks like nearly 1% of American girls in 2017 were named ‘Emma.’ Olivia, Liam and Noah are also overwhelmingly popular. What about my name? My birth year? Just replace my values with yours: babynames %&gt;% filter(name %in% c(&quot;Brian&quot;, &quot;Bryan&quot;)) %&gt;% filter(sex == &quot;M&quot;) %&gt;% ggplot(aes(year, prop, color = name)) + geom_line() babynames %&gt;% filter(year == 1975) %&gt;% arrange(desc(prop)) %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop),prop, fill = sex)) + geom_col() + coord_flip() I made the Top 10! (It’s all been downhill since then) Some reminders: We leave quotes off of the year, as it is numeric - only strings, or characters, get quotes. We make sure to reorder the data (based on popularity, or ‘prop’) before limiting it to the top 10 results. Otherwise, it could be organized alphabetically or something - and we’d be getting 10 names, but not the 10 most popular names. We have to reorder our name variable in the ggplot() to go in order of prop - even though we just reorganized the data this way 2 steps ago, ggplot() uses its own internal logic to organize the data. We have to plot as a bar chart, or column chart. Why? Because line charts are for continuous variables, like year - not discrete ones, like ‘name.’ If you can measure it, it’s continuous. If you can count it, it’s discrete. I encourage you to play around with babynames and get more comfortable deliberately modifying data before we continue. Or, if you’re getting sick of babies, you can use these tidyverse functions on any dataset. Let’s try using one of R’s built-in ones, mtcars: data(mtcars) View(mtcars) Looks like lots of older car performance statistics. Let’s try comparing weight to mpg: mtcars %&gt;% ggplot(aes(wt, mpg)) + geom_point() geom_point() creates a scatterplot, but we can also see hints of an overall trend, or correlation here - so let’s add that to the ggplot(): mtcars %&gt;% ggplot(aes(wt, mpg)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Let’s try adding color based on a variable: mtcars %&gt;% ggplot(aes(wt, mpg, color = cyl)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Great. On to mutate(). 1.6 Mutate While babynames has five columns, or variables, to play with, some observations require creating a calculated field of content - essentially generating a sixth column, in the case of babynames, to show something already in the data but not made clear. Babynames does not have rankings of popular names for each year. Could we create that column? Sure! When we rearrange our data in descending order of prop, we have essentially created rankings based on row number- we just need to ‘mutate’ the data frame to show it. babynames %&gt;% filter(year == 2017) %&gt;% arrange(desc(prop)) %&gt;% mutate(rank = row_number()) ## # A tibble: 32,469 × 6 ## year sex name n prop rank ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2017 F Emma 19738 0.0105 1 ## 2 2017 F Olivia 18632 0.00994 2 ## 3 2017 M Liam 18728 0.00954 3 ## 4 2017 M Noah 18326 0.00933 4 ## 5 2017 F Ava 15902 0.00848 5 ## 6 2017 F Isabella 15100 0.00805 6 ## 7 2017 F Sophia 14831 0.00791 7 ## 8 2017 M William 14904 0.00759 8 ## 9 2017 M James 14232 0.00725 9 ## 10 2017 F Mia 13437 0.00717 10 ## # … with 32,459 more rows That looks good! We can now save this new, mutated dataset: babynames %&gt;% filter(year == 2017) %&gt;% arrange(desc(prop)) %&gt;% mutate(rank = row_number()) -&gt; babynames_2017_ranked So mutate() creates a new column, and the values of that column are determined by some sort of calculation. Thus our code for mutate() declares the new column’s name (‘rank,’ in this case), and the calculation (‘row_number,’ in this case). Let’s try a practical use of mutate() by focusing on finding the most popular names of a particular generation. According to Wikipedia, the ‘Silent Generation’ were born between the years of 1928 and 1944: silent_gen &lt;- babynames %&gt;% filter(year &gt; 1927) %&gt;% filter(year &lt; 1945) Ok, we have sub-setted our data to only include the years of this generation. Let’s further simplify things by only looking at female names of the Silent Generation - and also add a ‘rank’ column: silent_gen %&gt;% filter(sex ==&quot;F&quot;) %&gt;% mutate(rank = row_number()) -&gt; silent_gen_f Ok, let’s see some results - what are the most popular female names of the Silent Generation? Let’s enhance the plot by adding a geom_text() object that fills in each name’s rank in its corresponding bar: silent_gen_f %&gt;% head(10) %&gt;% ggplot(aes(reorder(name, prop), prop, fill = &quot;red&quot;)) + geom_col() + coord_flip() + geom_text(aes(label = rank, hjust = 3)) It appears that Mary is the most popular name during this period. But wasn’t Mary popular back in 1890? Let’s look at these 10 names over time: babynames %&gt;% filter(name %in% c(&quot;Mary&quot;, &quot;Barbara&quot;, &quot;Betty&quot;, &quot;Doris&quot;, &quot;Dorothy&quot;, &quot;Helen&quot;, &quot;Margaret&quot;, &quot;Ruth&quot;, &quot;Shirley&quot;, &quot;Virginia&quot;)) %&gt;% filter(sex ==&quot;F&quot;) %&gt;% ggplot(aes(year, prop, color = name)) + geom_line() It appears that Mary is the most popular name for a very long time, gradually waning as more and more unique names get added to the database every year (therefore decreasing its proportion). Unlike the other 9 names, it definitely doesn’t peak during this generation - so let’s remove it. babynames %&gt;% filter(name %in% c(&quot;Barbara&quot;, &quot;Betty&quot;, &quot;Doris&quot;, &quot;Dorothy&quot;, &quot;Helen&quot;, &quot;Margaret&quot;, &quot;Ruth&quot;, &quot;Shirley&quot;, &quot;Virginia&quot;)) %&gt;% filter(sex ==&quot;F&quot;) %&gt;% ggplot(aes(year, prop, color = name)) + geom_line() That looks much better! What is that one name that is peaking like crazy right in the middle? babynames %&gt;% filter(name %in% &quot;Shirley&quot;) %&gt;% filter(sex ==&quot;F&quot;) %&gt;% ggplot(aes(year, prop, color = name)) + geom_line() Wow! What could we possibly blame this on? The popularity of Shirley Temple? There’s no way to quantitatively measure that, even if we think it to be true. 1.6.1 Group_by , summarise() Similar to creating a pivot table, the summarize() command reshapes your data by creating an entirely new dataset based on the parameters you specify. It is often used with the function group_by(). How is this useful, and how is it different from mutate? An example will help. If we look at most popular names of the Silent Generation, we see a lot of names repeated: silent_gen_f %&gt;% arrange(desc(prop)) %&gt;% head(10) ## # A tibble: 10 × 6 ## year sex name n prop rank ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1928 F Mary 66869 0.0559 1 ## 2 1930 F Mary 64146 0.0550 10712 ## 3 1929 F Mary 63510 0.0549 5437 ## 4 1931 F Mary 60296 0.0546 15960 ## 5 1932 F Mary 59872 0.0541 20937 ## 6 1933 F Mary 55507 0.0531 26037 ## 7 1934 F Mary 56924 0.0526 30895 ## 8 1935 F Mary 55065 0.0507 35868 ## 9 1937 F Mary 55642 0.0505 45616 ## 10 1936 F Mary 54373 0.0505 40760 If we want to count the total number of instances of each name over time, we’d have to use group_by() and summarise(), as well as n_distinct(), which counts the number of unique instances of a variable. In other words, if we want to see how many instances of each name there were per year, and plot it, we need to use summarize(): babynames %&gt;% group_by(year) %&gt;% summarise(name_count = n_distinct(name)) -&gt; distinct View(distinct) ggplot(distinct, aes(year, name_count)) + geom_line() Note that, unlike mutate(), summarize() removes all of our dataframe’s columns except the ones we specify we want to look at in both summarize() and group_by(). So if we want to ‘keep’ a variable in order to later visualize it, we have to add it to the group_by() function: babynames %&gt;% group_by(year, sex) %&gt;% summarise(name_count = n_distinct(name)) -&gt; distinct ## `summarise()` has grouped output by &#39;year&#39;. You can override using the `.groups` argument. ggplot(distinct, aes(year, name_count)) + geom_line() + facet_wrap(~sex) Summarize() is the most challenging of the basic dplyr functions, so don’t be discouraged if you struggle with it! Again, if already familiar with the concept of a Pivot Table, summarize() is basically the same, but in programmatic form: select the columns you wish to compare, strip away the rest of the data, and give me a simplified dataframe that can be visualized. When do you know to use summarize() instead of mutate()? Well, think of mutate as making a calculated field, adding a column to your dataframe - and summarize() as making a pivot table, stripping away most of your data to look at only a handful of columns in a new way. In the case of babynames, it’s clearly an appropriate time to use summarize() when you see the same name repeated over and over again in your results. We will revisit both techniques. Playing with the babynames dataset allows us to learn basic data manipulation and visualization, while avoiding other important topics, such as loading data files into R or doing basic statistical calculations - which we will get into shortly. In the meantime, play around with babynames and try to answer specific questions, such as: What generation saw the most births in the 20th Century? How have ‘virtue names,’ like ‘Charity,’ ‘Temperance,’ or ‘Faith’ fared in babynames: are they more or less popular now than in the past? What are the total number of names per year, and is this total increasing or decreasing? "],["basic-statistics.html", "Chapter 2 Basic Statistics 2.1 Variables &amp; Levels of Measurement 2.2 Statistical Analyses of a Single Variable", " Chapter 2 Basic Statistics This chapter uses data from Google Analytics’ channels report, which demonstrates how much of traffic is coming from specific paid versus unpaid channels, as well as data from social listening of #BlackLivesMatter and #StopAsianHate on Twitter to illustrate not only descriptive statistics that describe the properties of sample and population data but also inferential statistics for testing hypotheses and drawing conclusions regarding the relationships between variables. Specifically, we are going to introduce the fundamentals of statistics that cover various aspects of analyzing a single variable, two variables, and three or more variables. Let’s import the Google Analytics’ channels report into RStudio. #You will need to install readxl package library(readxl) my_data &lt;- read_excel(&quot;google analytics sample data.xlsx&quot;) #Create a dataset and name it as my_data Table 2.1 presents parts of a public demo dataset of channels report from Google Analytics of Google Merchandise Store, which is an affiliate of the holding company, Google, and an e-commerce business site that deals with marketing and selling of Google, YouTube, and Android branded merchandise such as stationaries, bags among other products. #You will need to install kableExtra package library(kableExtra) knitr::kable(head(my_data[,1:12], 20), digits = 5, booktabs = TRUE, caption = &#39;The First 20 Rows of the Google Analytics Sample Data&#39; ) %&gt;% kable_styling(font_size = 6.5) Table 2.1: The First 20 Rows of the Google Analytics Sample Data Channel Age Users New Users Sessions Bounce Rate Pages / Session Avg. Session Duration Ecommerce Conversion Rate Transactions Revenue Year Direct 25-34 81822 76251 118241 0.42193 5.82467 227.6724 0.03649 4315 332771.829 2021 Direct 18-24 65506 61565 88898 0.47178 4.98222 199.7854 0.02642 2349 198848.060 2021 Direct 35-44 41947 38535 59313 0.42185 5.91531 229.8105 0.03842 2279 189792.736 2021 Direct 45-54 26800 24967 37477 0.44659 5.47669 226.9229 0.03421 1282 109531.822 2021 Direct 55-64 12981 12217 17703 0.46444 5.26922 213.1094 0.03474 615 54808.702 2021 Direct 65+ 9432 8849 12548 0.46788 5.23932 210.5902 0.02981 374 35609.855 2021 Paid Search 18-24 2015 1766 2797 0.55703 4.71505 175.1087 0.02252 63 8423.719 2021 Paid Search 35-44 1394 1216 1980 0.47525 5.20909 157.2596 0.03535 70 8175.394 2021 Paid Search 25-34 2175 1829 3198 0.43809 5.88149 195.8474 0.03502 112 7576.795 2021 Direct 25-34 30772 29628 40539 0.37803 5.78436 233.6450 0.00306 124 7240.313 2020 Direct 18-24 17545 17024 21888 0.42708 5.07753 210.2462 0.00315 69 5325.412 2020 Direct 45-54 8491 8126 11115 0.38570 5.73117 230.9463 0.00495 55 4173.602 2020 Paid Search 45-54 1083 960 1387 0.56669 4.39726 138.6871 0.02307 32 4086.483 2021 Direct 35-44 14088 13560 18461 0.38248 5.53648 226.3607 0.00444 82 3993.809 2020 Organic Search 25-34 35978 32853 47132 0.51390 3.97070 164.3456 0.00068 32 1738.469 2020 (Other) 35-44 284 174 523 0.24474 7.62524 278.2505 0.03824 20 1657.444 2021 Direct 55-64 4466 4287 5862 0.40242 5.46571 232.1102 0.00409 24 1530.108 2020 (Other) 25-34 3440 2370 4741 0.31533 5.90719 232.4685 0.00337 16 1472.471 2020 (Other) 18-24 500 302 849 0.34982 5.61602 244.2697 0.03651 31 1395.053 2021 Paid Search 55-64 804 748 1009 0.62537 3.59068 111.0684 0.01388 14 1315.551 2021 See the bibliography at the end of the chapter for referral to the complete dataset that you can access and work with. 2.1 Variables &amp; Levels of Measurement In a dataset, the columns identify the variables that represent certain qualities of individuals. Any quality that can vary can be considered a variable. Variables can take on different values or attributes. An attribute is a specific value on a variable. For example, gender might be a variable that we are interested in, and the attributes of gender could be male, female, transgender, and non-binary. We use levels of measurement to describe how precisely variables are recorded. There are four levels of measurement: nominal, ordinal, interval, and ratio representing the transition from analyzing qualitative to quantitative data. 2.1.1 Nominal Data Nominal data is used to label variables. Gender, nationality, race, and ethnicity are a few of the most common examples of nominal data. It can only be categorized based on qualitative differences and there are no orderings or directions among different categories. We only know that males and females have qualitative differences in terms of gender, but we cannot tell how much they differ, nor could we sort individuals based on their gender. We can still assign numbers to different attributes of nominal variables (e.g., we can assign 1 to females and 2 to males, or vice versa), but the numbers only serve as labels that lack numerical values. For the dataset of Google Analytics from Google Merchandise Store (Table 1), the variable Channel is measured at the nominal level, and it indicates the channel through which traffic got to Google Merchandise Store. Organic Search indicates visits from unpaid search results. Direct indicates visits where users navigated directly to the URL, or the source of the visit is unknown. Referral indicates traffic where users clicked a link from another site, excluding major search engines. Display indicates traffic from display advertising, such as Google AdWords remarketing campaigns. Social indicates visits from social networks (Facebook, Twitter, etc.). Paid Search indicates traffic from the PPC (Pay Per Click) campaigns run in search results. Since each variable should be exhaustive to include all the possibilities, for the variable of Channel, the attribute “Other” is assigned referring to traffic from an un-identified channel. All these different channels through which a user reaches our website are different attributes our channel variable can have. 2.1.2 Ordinal Data Ordinal data also can be categorized, but there are rankings or orderings or scaling between categories. The ordinal measurement has been widely used to analyze variables such as education level (e.g., “high school,” “BS,” “MS,” “Ph.D.”), income level (e.g., “less than 50K,” “50-100K,” “over 100K”), and socioeconomic status (e.g., “lower class,” “middle class,” and “upper class”). For the dataset of Google Analytics from Google Merchandise Store (Table 2.1), the variable Age is also ordinal, and it refers to the age group of the users. For such ordinal variable, we can turn it into quantitative by assigning numerical values to different categories. For example, Age can be defined as having six attributes:1 = 18-24; 2 = 25-34; 3 = 35-44; 4 = 45-54; 5 = 55-64; 6 = 65+. There is a logical ordering among the different age groups, in a way that whoever answers “6” is older than individuals who answer “5” to this question. However, we cannot precisely tell the differences between the two groups because each attribute covers a wide range, and the ranges of different attributes are of different sizes. 2.1.3 Interval Data Interval data refers not only to the classification and ordering of data but also specifies that the distances between every two adjacent attributes on a scale are equal. For interval data, the difference between two values is meaningful, but there is no true zero point or fixed beginning, which refers to a scale where 0 indicates the absence of something. The most popular example is the temperature in degrees Fahrenheit or Celsius. The difference between 90 degrees F and 80 degrees F is the same difference between 70 degrees F and 60 degrees F; however, when it comes to 0 degrees F, we cannot say that temperature no longer exists. For interval measures, the value 0 does not mean the absence of this variable; rather, it is just an arbitrary setting that we have agreed upon. Another example of interval data is year. For year, 0 does not represent the missing value but indicates the year when Christ was born, and the time before 0 is given the prefix BC. If you were born in the year of 2005 and I was born in the year of 2000, we know that I will be five years older than you. For the dataset of Google Analytics from Google Merchandise Store (Table 2.1), the only interval variable is Year, indicating the year of each observation. 2.1.4 Ratio Data For ratio data, the difference between two values is also meaningful, and it has a true zero, indicating the absence of such variable. Media consumption is a great example of ratio data. Media consumption can be measured in days, hours, or minutes a person exposes him/herself to media content. If a person has zero media consumption, that means this person does not consume media at all; in other words, to this person, media consumption is absent. For ratio data, zero is the starting point, and the distance between two adjacent values is the same. In addition, it makes sense to calculate the ratio of different values: If you have six hours of media consumption and I only have three hours, then we can say that you consume twice as much media as I do. Table 2.1 has six ratio variables. Sessions are the total number of sessions within the date range. A session is the period time a user is actively engaged with the website of Google Merchandise Store. Users are the number of users who have initiated at least one session during the date range, with the value of zero representing no such user exists. New Users are the number of first-time users during the selected date range. Transactions are the number of completed purchases on Google Merchandise Store. Ecommerce Conversion Rate refers to the E-commerce conversion rate that is the percentage of sessions that resulted in an e-commerce transaction. Revenue refers to the revenue of the completed purchases. If the revenue from the display channel is 0, that just means there is no income produced by the display Ads. What you can do to analyze your data may be limited due to the level of measurement of the variable. The complexity and precision of the level of measurement increase from nominal to ratio. For the ratio level of measurement, we can not only add numbers or subtract numbers but calculate the ratio of two numbers. For example, if the revenue from the organic search channel is 8k and from the paid search is 4k, then the revenue generated from organic search is twice as much as the revenue from paid search. The rows in a spreadsheet are closely associated with the unit of analysis, which is one of the most important ideas in a research project and the major entity that you are analyzing in your study. You will need to determine the unit of analysis since it determines the analysis you do for your research. For instance, if you are comparing the e-commerce performances (e.g., User, Sessions, Transactions, Revenues, ECR) of different channels, the unit of analysis is each individual channel. If you are comparing the e-commerce performance of different age groups, the unit of analysis is each age group. If you are comparing the e-commerce performance of different channels and age groups, the unit of analysis is each individual channel at each age group. 2.2 Statistical Analyses of a Single Variable After defining your research questions and the related unit(s) of analysis, and levels of measurement, we may start the data analysis journey by conducting a statistical analysis of a single variable. 2.2.1 Frequency Distribution The easiest thing we can do is to count the number of times an event or a value occurs for the variable(s) of our choice, and this is called Frequency analysis. We can aggregate individual observations of a variable into groups so that a frequency distribution of these groups can serve as a convenient means of summarizing or describing our data. We are going to use the dplyr package to count the aggregated transactions by channel and age groups. #Frequency and grouped frequency analysis #You will need to install dplyr package library(dplyr) Transaction_Frequency_Channel &lt;- my_data %&gt;% group_by(Channel) %&gt;% summarise(Frequency = sum(Transactions)) Transaction_Frequency_Age &lt;- my_data %&gt;% group_by(Age) %&gt;% summarise(Frequency = sum(Transactions)) Table 2.2 demonstrated the grouped frequency of transactions for each channel and age group. From the frequency analysis, we can tell that the direct channel (n = 11581) and the age group of 25 to 34 (n = 4654) had the greatest number of transactions in Google Merchandise Store. knitr::kable( list( head(arrange(Transaction_Frequency_Channel, desc(Frequency))), head(arrange(Transaction_Frequency_Age, desc(Frequency)))), booktabs = TRUE, caption = &#39;Grouped Transaction Frequency for Channel and Age&#39; ) %&gt;% kable_styling(font_size = 14) Table 2.2: Grouped Transaction Frequency for Channel and Age Channel Frequency Direct 11581 Paid Search 330 (Other) 138 Organic Search 98 Referral 32 Display 6 Age Frequency 25-34 4654 18-24 2558 35-44 2496 45-54 1394 55-64 673 65+ 414 2.2.2 Percentage Change Here, we can also use the grouped frequency analysis to compare the revenue from each channel between 2020 and 2021 to assess the dynamic changes of each channel. #Creat a subset for year 2020 and year 2021 my_data_2020 &lt;- my_data %&gt;% filter(Year == 2020) my_data_2021 &lt;- my_data %&gt;% filter(Year == 2021) Revenue_Frequency_2020 &lt;- my_data_2020 %&gt;% group_by(Channel) %&gt;% summarise(Revenue = sum(Revenue)) Revenue_Frequency_2021 &lt;- my_data_2021 %&gt;% group_by(Channel) %&gt;% summarise(Revenue = sum(Revenue)) As illustrated in Table 2.3, the direct channel created the most revenues in both 2020 and 2021. When you have such data for two points in time, you can calculate how much change there has been over this period. The result is expressed as a percentage in absolute numbers and is called the percentage change or the rate of change. Here is the formula: Percentage Change = [(Number at later time / Number at earlier time) - 1] × 100%. knitr::kable( list( head(arrange(Revenue_Frequency_2020, desc(Revenue))), head(arrange(Revenue_Frequency_2021, desc(Revenue)))), booktabs = TRUE, caption = &#39;Grouped Revenue in 2020 and 2021&#39; ) %&gt;% kable_styling(font_size = 14) Table 2.3: Grouped Revenue in 2020 and 2021 Channel Revenue Direct 23565.6812 Organic Search 4628.4410 (Other) 3154.8063 Paid Search 1975.9309 Referral 864.7263 Social 164.8144 Channel Revenue Direct 921363.0041 Paid Search 29908.1791 (Other) 5193.1180 Referral 852.0686 Display 354.3391 Organic Search 188.6451 For example, from Table 2.3, in 2020, the revenue generated from the paid search channel was $1975.93. And in 2020, the revenue generated from the paid search channel was 29908.18. The percentage change of revenue from the paid search channel from 2020 to 2021 is then calculated as follows: [(29908.18/ 1975.93)-1] x 100%= 1413.62%, meaning that from the year of 2020 to the year of 2021, the revenue generated from the paid search channel increased by 1413.62%. 2.2.3 Relative Frequency For the frequency analysis, we also can count how often something happens divided by all outcomes, which is called the relative frequency analysis. For example, from Table 3, the revenue from the organic search channel in 2020 is $4,628.44, and the total revenue in 2020 is the sum of revenue from all channels, which is $34422.26.The relative revenue from the organic search channel is 4,628.44/34422.26 = 13.44%, indicating 13.44% of the revenue in 2020 was from the organic search channel. We can use the codes below to get the relative revenue for each channel in 2020 and 2021 (Table 2.4). Revenue_Relative_Frequency_2020 &lt;- my_data_2020 %&gt;% group_by(Channel) %&gt;% summarise(&#39;Revenue_Percentage&#39; = sum(Revenue)/sum(my_data_2020$Revenue)) Revenue_Relative_Frequency_2021 &lt;- my_data_2021 %&gt;% group_by(Channel) %&gt;% summarise(&#39;Revenue_Percentage&#39; = sum(Revenue)/sum(my_data_2021$Revenue)) knitr::kable( list( head(arrange(Revenue_Relative_Frequency_2020, desc(Revenue_Percentage))), head(arrange(Revenue_Relative_Frequency_2021, desc(Revenue_Percentage)))), booktabs = TRUE, caption = &#39;Grouped Revenue in 2020 and 2021&#39; ) %&gt;% kable_styling(font_size = 14) Table 2.4: Grouped Revenue in 2020 and 2021 Channel Revenue_Percentage Direct 0.6846058 Organic Search 0.1344607 (Other) 0.0916502 Paid Search 0.0574027 Referral 0.0251211 Social 0.0047880 Channel Revenue_Percentage Direct 0.9618529 Paid Search 0.0312225 (Other) 0.0054213 Referral 0.0008895 Display 0.0003699 Organic Search 0.0001969 2.2.4 Percentage Points We can use the term “percentage points” to compare two different percentages at two points in time. The best way to explain this is through an example: from Table 2.4, in 2020, the share of revenue from the Paid Search channel was 5.74%. In 2021, the share of revenue from the Paid Search channel was 3.12%. The difference of these two percentages is calculated in percentage points: 3.12 % - 5.74 % = -2.62%. This means that the share of revenue from Paid Search channel in 2021 was almost three percentage points lower than the share of revenue from the Paid Search channel in 2020. 2.2.5 Rate In data analysis, some variables, such as the ECR (e-commerce conversion rate from Table 2.1), are too small to visualize. Under such circumstances, we can represent the percentage as rate by converting the small proportions to a whole number with one, two, or three digits on a base of some multiple of 1,000, 10,000, 100,000, or 1 million. For example, from Table 2.1, in 2020, the Ecommerce Conversion Rate of the organic search channel for users of 25 to 34 is 0.00068 or 0.068%. Instead of reporting the percentage, we can move the decimal place farther to the right, sufficient to make a number greater than 1, which allows us to better visualize the data. In the case of Ecommerce Conversion Rate, moving the decimal point four places to the right is the same as multiplying the value by 10,000. Consequently, the Ecommerce Conversion Rate of the organic search channel was 6.8 per 10,000 sessions. We can use the r code below to add a column representing the Ecommerce Conversion Rate per 10,000 sessions for my_data. my_data$ECR &lt;- my_data$`Ecommerce Conversion Rate`*10000 Now, the new column has been added to my_data as illustrated in Table 2.5. knitr::kable(head(my_data[,1:13], 20), digits = 5, booktabs = TRUE, caption = &#39;The First 20 Rows of the Google Analytics Sample Data&#39; ) %&gt;% kable_styling(font_size = 6.5) Table 2.5: The First 20 Rows of the Google Analytics Sample Data Channel Age Users New Users Sessions Bounce Rate Pages / Session Avg. Session Duration Ecommerce Conversion Rate Transactions Revenue Year ECR Direct 25-34 81822 76251 118241 0.42193 5.82467 227.6724 0.03649 4315 332771.829 2021 364.93264 Direct 18-24 65506 61565 88898 0.47178 4.98222 199.7854 0.02642 2349 198848.060 2021 264.23542 Direct 35-44 41947 38535 59313 0.42185 5.91531 229.8105 0.03842 2279 189792.736 2021 384.23280 Direct 45-54 26800 24967 37477 0.44659 5.47669 226.9229 0.03421 1282 109531.822 2021 342.07647 Direct 55-64 12981 12217 17703 0.46444 5.26922 213.1094 0.03474 615 54808.702 2021 347.39875 Direct 65+ 9432 8849 12548 0.46788 5.23932 210.5902 0.02981 374 35609.855 2021 298.05547 Paid Search 18-24 2015 1766 2797 0.55703 4.71505 175.1087 0.02252 63 8423.719 2021 225.24133 Paid Search 35-44 1394 1216 1980 0.47525 5.20909 157.2596 0.03535 70 8175.394 2021 353.53535 Paid Search 25-34 2175 1829 3198 0.43809 5.88149 195.8474 0.03502 112 7576.795 2021 350.21889 Direct 25-34 30772 29628 40539 0.37803 5.78436 233.6450 0.00306 124 7240.313 2020 30.58783 Direct 18-24 17545 17024 21888 0.42708 5.07753 210.2462 0.00315 69 5325.412 2020 31.52412 Direct 45-54 8491 8126 11115 0.38570 5.73117 230.9463 0.00495 55 4173.602 2020 49.48268 Paid Search 45-54 1083 960 1387 0.56669 4.39726 138.6871 0.02307 32 4086.483 2021 230.71377 Direct 35-44 14088 13560 18461 0.38248 5.53648 226.3607 0.00444 82 3993.809 2020 44.41796 Organic Search 25-34 35978 32853 47132 0.51390 3.97070 164.3456 0.00068 32 1738.469 2020 6.78944 (Other) 35-44 284 174 523 0.24474 7.62524 278.2505 0.03824 20 1657.444 2021 382.40918 Direct 55-64 4466 4287 5862 0.40242 5.46571 232.1102 0.00409 24 1530.108 2020 40.94166 (Other) 25-34 3440 2370 4741 0.31533 5.90719 232.4685 0.00337 16 1472.471 2020 33.74815 (Other) 18-24 500 302 849 0.34982 5.61602 244.2697 0.03651 31 1395.053 2021 365.13545 Paid Search 55-64 804 748 1009 0.62537 3.59068 111.0684 0.01388 14 1315.551 2021 138.75124 2.2.6 Ratio Ratio compares the size of two numbers indicating how many times one number contains another. For example, let’s calculate the ratio of returning users and new users using the formula: Number of Old Users / Number of New Users. We first use the r code below to create a new column old user (users - new users), then we use the group_by function to calculate the ratio fo returning users and new users for each channel. #creating a new colunme of old users my_data$OldUsers &lt;- my_data$Users-my_data$&#39;New Users&#39; userratio &lt;- my_data %&gt;% group_by(Channel) %&gt;% summarise(OldUsers = sum(OldUsers), NewUsers = sum(`New Users`),Ratio = sum(OldUsers)/sum(`New Users`)) From Table 2.6, we can find that besides the un-defined channel, the referral channel has a relatively higher ratio of returning (old) users to new users, indicating a better retention rate. knitr::kable( head(arrange(userratio, desc(Ratio))), booktabs = TRUE, caption = &#39;The Ratio of Old Users and New Users for Each Channel&#39; ) %&gt;% kable_styling(font_size = 14) Table 2.6: The Ratio of Old Users and New Users for Each Channel Channel OldUsers NewUsers Ratio (Other) 3383 7268 0.4654651 Referral 8101 23027 0.3518044 Paid Search 2116 11593 0.1825239 Affiliates 1002 8071 0.1241482 Organic Search 8428 81809 0.1030205 Display 524 7624 0.0687303 2.2.7 Central Tendency Besides using frequency analysis to summarize the distribution of a variable, we also can use the central tendency analysis to understand which attribute of a variable is most typical or representative of the variable distribution. Specifically, the central tendency analysis describes what the center of the data for a variable is. What do we mean by the center of the data? For many, the mean, median, and mode. Mean is the sum of all data points divided by the total number of observations. Median is the midpoint in data with an equal number of data points above and below. If the number of data points is even, then Median is the mean of the two midpoints. Mode is the data point that is most prevalent in the data set. It represents the most likely outcome in a data set. Let’s first create a small dataset of test scores from 20 students. StudentID &lt;- c(1:20) Score &lt;- c(40,50,50,60,60,60,60,60,70,70,70,80,80,80,80,90,90,90,90,100) TestData &lt;- data.frame(StudentID, Score) ScoreFrequency &lt;- as.data.frame(table(TestData$Score)) # Calculate the frequency of each score colnames(ScoreFrequency) &lt;- c(&quot;Score&quot;,&quot;Frequency&quot;) Table 2.7 demonstrates the frequency of each score. knitr::kable( head(arrange(ScoreFrequency)), booktabs = TRUE, caption = &#39;Frequency of Test Scores from 20 Students&#39;, align = &quot;l&quot; ) %&gt;% kable_styling(font_size = 16) Table 2.7: Frequency of Test Scores from 20 Students Score Frequency 40 1 50 2 60 5 70 3 80 4 90 4 The mean score is the sum of all scores divided by 20. The related formula is: (40x1 + 50x2 + 60x5 + 70x3 + 80x4 +90x4 + 100x1)/20 = 71.5, meaning that the average score among these 20 students is 71.5. When it comes to identifying the median value, we want to sort all individuals from the lowest value to the highest value, and whoever in the middle gives us the median value. But the problem is, we have 20 students in this sample, which is an even number, meaning that there will be two individuals in the middle (Table 2.8: student number 10 and number 11). For situations like this, we take the mean of these two individuals’ values to compute the median: (70+70)/2 = 70 (Table 2.8). knitr::kable(head(TestData, 20), booktabs = TRUE, caption = &#39;A Small Dataset of Test Scores from 20 Students&#39;, align = &quot;l&quot; ) %&gt;% kable_styling(font_size = 16) Table 2.8: A Small Dataset of Test Scores from 20 Students StudentID Score 1 40 2 50 3 50 4 60 5 60 6 60 7 60 8 60 9 70 10 70 11 70 12 80 13 80 14 80 15 80 16 90 17 90 18 90 19 90 20 100 We can easily identify the most frequent test score by looking into the score distribution visualization. # You will need install ggplot2 package library(ggplot2) # Barplot ggplot(ScoreFrequency, aes(x=Score, y=Frequency)) + geom_bar(stat = &quot;identity&quot;) Figure 2.1: Distribution of Test Scores from 20 Students Since 60 is the most frequent data point, it is the mode of the dataset. When we do the central tendency analysis, we also need to consider the data types. While interval and ratio data have a median, mode, and mean, the nominal data has only a mode. Furthermore, when the data distribution is symmetrical, such as your data is normally distributed, the mean is the best measure of central tendency. But, when the dataset has a strongly skewed distribution, the best indicator of central tendency is the median or mode, with the median usually preferred. Now we can use the code below to get the mean, median, and mode for the number of Users and New Users, number of Sessions, E-commerce Conversion Rates, Transactions, and Revenues for the Google analytics data of the Google Merchandise Store. #Calculate mean for each col mean_report &lt;- my_data %&gt;% summarise_if(is.numeric, mean) #Calculate median for each col median_report &lt;- my_data %&gt;% summarise_if(is.numeric, median) #Create the mode function getmode &lt;- function(v) { uniqv &lt;- unique(v) uniqv[which.max(tabulate(match(v, uniqv)))] } #Calculate mode for each col mode_report &lt;- my_data %&gt;% summarise_if(is.numeric, getmode) #combine the reports centerreport &lt;- as.data.frame(rbind(mean_report, median_report, mode_report)) rownames(centerreport) &lt;- c(&quot;Mean&quot;,&quot;Median&quot;,&quot;Mode&quot;) centerreport &lt;- centerreport[, -10] knitr::kable( head(arrange(centerreport)), booktabs = TRUE, caption = &#39;Descriptive Statistics-mean,median,mode&#39;, align = &quot;l&quot; ) %&gt;% kable_styling(font_size = 14) Table 2.9: Descriptive Statistics-mean,median,mode Users New Users Sessions Bounce Rate Pages / Session Avg. Session Duration Ecommerce Conversion Rate Transactions Revenue ECR OldUsers Mean 5661.279 5162.767 7707.93 0.4893791 4.868766 188.0428 0.0113537 141.7326 11538.6812 113.53744 498.5116 Median 940.500 768.500 1162.00 0.4757293 5.019697 193.5811 0.0022378 3.0000 131.0928 22.37833 116.5000 Mode 22.000 0.000 118241.00 0.4219349 5.824672 227.6724 0.0000000 0.0000 0.0000 0.00000 3412.0000 It is interesting to find the huge discrepancies between different central tendency measurements. This also indicates reporting results of different central tendency analyses can provide a more comprehensive understanding of the data distribution. For example, the mean value of Users (5661) is much higher than the median (940) and mode (22), indicating a skewed data distribution due to the existence of some large-value outliers. Weighted Mean is a special mean where some data points contribute more than others. To calculate the weighted mean, we need to consider the weight for each data point. For example, we can calculate the weighted mean of the E-commerce Conversion Rate by taking the number of users as weight. The more users each data point has, the larger weight for its E-commerce Conversion Rate (ECR). In R, we can use the function of weighted.mean as below to get the weighted mean of the ECR of the Google Store: #Calculated the weighted mean for ECR weighted.mean(my_data$`Ecommerce Conversion Rate`, my_data$Users) ## [1] 0.01783514 When taking the number of users into consideration, the weighted mean of the E-commerce Conversation Rate is almost 18 per 10,000 sessions, which is a bit higher than the normal mean, 11 per 10,000 sessions (Table above). This also indicates that the data points with high E-commerce Conversion Rates had more users than those with low rates. 2.2.8 Data Variation If two data sets have the same center points, does that mean they have the same data distribution? Let’s look at two small datasets: Score1 &lt;- data.frame(c(110, 90,70,50,30)) Score2 &lt;- data.frame(c(75, 70,70,70,65)) colnames(Score1) &lt;- c(&quot;Score1&quot;) colnames(Score2) &lt;- c(&quot;Score2&quot;) knitr::kable( list( head(arrange(Score1, desc(Score1))), head(arrange(Score2, desc(Score2)))), booktabs = TRUE, caption = &#39;Two Small Data Sets with the Same Mean and Median&#39; ) %&gt;% kable_styling(font_size = 14) Table 2.10: Two Small Data Sets with the Same Mean and Median Score1 110 90 70 50 30 Score2 75 70 70 70 65 Although they have the same mean (70) and median (70), the detailed data distributions vary significantly in a way that indicates the data in data set 1 were more spread out. This indicates that the mere central tendency measures cannot 100% accurately represent distribution. While the central tendency is the key to data description and prediction, variation is used to evaluate the quality of central tendency measures, and it plays an essential role in explaining statistical contribution. Variation Ratio reflects the proportion of cases that are not in the mode category. For example, from Table 8, the mode for Session is 3787. But this mode contains only two cases. Since the number of observations is 96, The variation ratio for Session is: (96-2)/96 = .98 or 98%, indicating the mode of 3787 is not a very representative indicator of sessions. To the contrary, for the variable of Transaction, the mode was 0 with 53 data points taking this value. The variation ratio of transaction is: (96-53)/96 = .45 or 45%, indicating “0” demonstrated relatively strong representativeness of transaction. This variation ratio also reflects the need for improvements of conversions for a variety of channels for the Google Merchandise Store. Range The worth of the median as a measure of central tendency is dependent on how narrowly scores are dispersed in the distribution. The range is the difference between the highest and lowest scores of a distribution. In our dataset, the range in class sizes is 237-17=220. As you can see, any ex treme score in a distribution, commonly referred to as an outlier, will greatly af fect the range. That much sensitivity is not desirable. Inter-ranges A more stable set of measures, called inter-ranges, drop off a specified highest and lowest percentage of the cases. The most popular are the inter-decile range, inter-quintile range, and inter-quartile range. Deciles are tenths, quintiles are fifths, and quartiles are fourths. These inter-ranges drop off the highest and lowest 10%, 20% and 25% of the cases, respectively, and then calculate the range of the remaining cases. For example, the inter-quartile range for class size in our small dataset would drop off the highest one-fourth and lowest one-fourth of the 23 cases. Since onefourth of 23 is not an even number (23/4=5.75), we’ll round up and drop off the top six (237, 133, 124, 103, 97, 90) and bottom six cases (17, 19, 19, 22, 23, 25). Of the remaining scores, the range is 56 (83-27). It is proper to say, then, that the range of the middle 50% of the cases is 56. The median score, 40 in this case, remains, of course, at the center of these mid dle 50% of the cases. sd 2.2.9 Case Study "],["text-analysis.html", "Chapter 3 Text Analysis", " Chapter 3 Text Analysis "],["network-analysis.html", "Chapter 4 Network Analysis", " Chapter 4 Network Analysis "],["geo-spatial-analysis-and-visualizations.html", "Chapter 5 Geo-Spatial Analysis and Visualizations", " Chapter 5 Geo-Spatial Analysis and Visualizations "],["publishing.html", "Chapter 6 Publishing", " Chapter 6 Publishing "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
