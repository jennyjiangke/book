# Text Analysis 

## An Introduction to Stringr

```{r}
library(babynames)
library(tidyverse)
library(tidytext)
library(textdata)
```

Stringr is a package in the *tidyverse* that deals with, well, strings. What are strings? Anything in your data frame that is text- or character-based. So, in the case of *babynames*, that'd be *Name* and *Sex -* Year, Prop and N are not strings.

Stringr allows for string manipulation across your entire dataset. If, for instance, we had a column of character data that repeatedly mis-spelled a name: *Bryan* instead of *Brian*, say - stringr could change every instance of *Bryan* into *Brian* in one line of code.

Let's start playing around with stringr by creating a *variable* that is equal to a string:

```{r, stringr1}
library(stringr)

sentence <- c("hello", "this is a long sentence", NA)
```

Here are some functions from the stringr package that we can use to manipulate this sentence.
<ul><li>
How many characters are there in the string?

```{r, stringr1b}
str_length(sentence)
```

<li>Let's replace every instance of 'l' with 'x'
```{r}
str_replace(sentence, "l", "X")
```

Okay, now let's create a new string that is a *list* of character strings:

```{r, stringr 1c}

list <- c("Apple", "Banana", "Pear")

```

Let's use str_sub to 'pull out' the first character of the string:

```{r, stringr 1d}
str_sub(list, 1,1)
```

What just happened? We told R to only grab the first character. Can we grab the first three characters?

```{r, stringr 1e}
str_sub(list, 1,3)
```

Let's adjust the string's content so each fruit is written entirely in lower case:

```{r, stringr 1f}
str_to_lower(str_sub(list))
```

We can also use stringr to detect specific words or phrases:

```{r, stringr 1g}
str_detect(list, "Pear")
```

R returns the position of "Pear" in the list.

### Practical Applications of Stringr

Let's apply more Stringr concepts to a body of text. Where could we find text? How would we get text into R?

One way would be a 'web scrape' - programmatically grabbing all the relevant text off of a page, or a series of pages - think Amazon product reviews.

Another would be to import a body of text, like a .txt file, into R, and then break it up into individual words - more on this in the next chapter.

A third way would be to use data included in an R package. More commonly, packages give you *access* to online datasets too large to download (Spotify, The New York Times, etc.). This technique, of selectively downloading relevant data from a much larger, online database, is the basis for the concept of an 'API.' [*Application Programming Interface*, if you're wondering.] Many websites also use APIs, with downloadable files for analysis.

So as to avoid any complication, let's hold off on accessing an API until we cover Twitter, and continue to use the *babynames* dataset for now; then we can move on to analyzing lyrics, political speeches, and great works of literature.

A snippet of *Base R* here, rather than the *tidyverse*: if we want to specify a *column* in our dataset, we write the name of the dataset or variable, then the dollar sign, then the name of the column:

```{r}
babynames$name

```

Let's use str_detect() to find all of the names that include a 'sh' sound:

```{r, include = FALSE}
str_detect(babynames$name, "Sh")
```

As you see, str_detect() runs as a *boolean operator*, in that it ascribes a *TRUE* or *FALSE* value for each entry in the column, based on our conditional statement: is there a 'sh' in the character string?

Let's combine our previous experience with ggplot to write a long, complicated set of code that will visualize the *most popular names starting in 'Sh' for women born in 1938:*

```{r}
babynames %>% 
  filter(str_detect(name, "Sh") & sex=="F" & year == 1938) %>% 
  arrange(desc(prop)) %>% 
  head(20) %>% 
  ggplot(aes(reorder(name,prop),prop,  fill = name)) + 
  geom_col() +
  coord_flip()
```

Let's fancy that up a bit, by calculating a 'percentage' of use of that name per year / per gender:

```{r}
babynames %>% 
  filter(str_detect(name, "Sh") & sex=="F" & year == 1938) %>% 
  arrange(desc(prop)) %>% 
  head(20) %>% 
  mutate(percent = (prop * 100)) %>% 
  ggplot(aes(reorder(name,percent),percent,  fill = name)) + 
  geom_col() +
  coord_flip()
```

how many 'z' names since 2000?

```{r}
babynames %>% 
  filter(year > 2000 & str_detect(name, "Z")) %>% 
  arrange(desc(prop))
```

Why did R only pull out the names starting with Z? Because we capitalized it. How do we get both?

```{r}
    babynames %>% 
      mutate(Z = str_count(babynames$name, "[zZ]")) %>% 
      arrange(desc(prop))
```

Instead of arranging our data by name popularity, let's look at the names with the *most* z's in them:

```{r}
    babynames %>% 
      mutate(Z = str_count(babynames$name, "[zZ]")) %>% 
      arrange(desc(Z))
```

What if, instead of specifying a particular letter, we just wanted to count the most frequent first letters in names?

```{r}
    babynames %>% 
      mutate(first_letter = substr(name, 1,1)) -> baby_letters
```

Let's plot that:

```{r}
    baby_letters %>% 
      count(first_letter, sort = TRUE) %>% 
      ggplot(aes(reorder(first_letter, n),n)) + 
      geom_col() +
      coord_flip()
```

We can also use stringr to calculate the length of all of our strings. What is the frequency of the shortest and longest names?

```{r}
    babynames %>% 
      mutate(length = str_length(name)) -> babynames_length
```

### Average name length over time

Now, if we want to see the average length of a names over time, the code gets a little mroe advanced - note the *mean* function we haven't used like this before:

```{r}
    babynames_length %>% 
      group_by(year) %>% 
      summarise_at(vars(length), funs(mean(.))) %>% 
      ggplot(aes(year, length)) + geom_line()
```

The results are impressive. Let's split them up by Sex:

```{r}
    babynames_length %>% 
      group_by(year, sex) %>% 
      summarise_at(vars(length), funs(mean(.))) %>% 
      ggplot(aes(year, length, color = sex)) + geom_line()
```

### Common issue: (example: most common 3-letter names)

As mentioned in the last Chapter, summarise() is confusing. In the case of babynames, you'll know to use it when you keep getting the same results over and over, and you want to group those names together. Let's take a look at this issue by calculating the most common 3-letter names:

```{r}
    babynames_length %>% 
      filter(length == 3) %>% 
      arrange(desc(prop))
```

We get a lot of repeated names. Time to summarize!

```{r}
    babynames_length %>% 
      filter(length == 3) %>% 
      group_by(name) %>% 
      summarise(total = sum(n) ) %>% 
      arrange(desc(total))
```

Let's try that again, with 2-letter names:

```{r}

    babynames_length %>% 
      filter(length == 2) %>% 
      group_by(name) %>% 
      summarize(total = sum(n)) %>% 
      arrange(desc(total)) 
```

What is the longest name?

```{r}
    babynames_length %>% 
      arrange(desc(length))
```

How many 15 letter names are there?

```{r}
    babynames_length %>% 
      filter(length == 15) %>% 
      count(name, sort = TRUE)
```

Let's plot those names:

```{r}
    babynames %>% 
      filter(name %in% c("Christopherjohn","Johnchristopher","Christopherjame","Franciscojavier", "Christophermich", "Ryanchristopher","Christianjoseph", "Christopherjose", "Jonathanmichael", "Mariadelosangel"  
      )) %>% 
      ggplot(aes(year, prop, color = name)) + geom_line() 
```

By the look of these names, it's clear that most of them are actually *longer* than 15 characters - but 15 characters is the cut-off point for the column. Thus, we cannot accurately estimate the most common 15-letter names.

Along similar lines, an analysis of the methodology behind *babynames* shows that only names that have *at least 5 instances in a given year* are recorded. So it'd be similarly futile for us to attempt to measure the *rarest* names, as they are excluded in the database. (It also helps clarify why some rarer names seem to 'disappear' in certain years.)

OK, what else can stringr do?

How about the average number of vowels per name?

```{r}
 str_count(babynames$name, "[aeiou]")
```

That's a lot of numbers. Let's calculate a mean value instead:

```{r}
 mean(str_count(babynames$name, "[aeiou]"))
```

How about consonants?

```{r}
     mean(str_count(babynames$name, "[bcdfghjklmnpqrstvwxyz]"))
```

Example ideas for further exploration:

How many names contain 'liz' in them?

```{r}
    babynames %>% 
      filter(str_detect(babynames$name, "liz") )  %>% 
      count(name, sort = TRUE) %>% 
      head(20) %>% 
      ggplot(aes(reorder(name, n),n)) + geom_col() + 
      coord_flip()
```

Case Study: Born Without A (Proper) Name

There are a number of names in the database that are totally anonymous. When, and why?

```{r}
babynames %>% 
  filter(name %in% c("Unknown", "Unnamed", "Infant", "Infantof", "Notnamed", "Baby")) %>% 
  ggplot(aes(year, prop, color = name)) + geom_line() + facet_wrap(~sex)
```

Let's compare this to the number of unique names per year:
```{r}                                    
babynames %>% 
  group_by(year) %>% 
  summarize(annual = n_distinct(name)) %>% 
  ggplot(aes(year, annual )) + geom_line()
```

*Babynames* also includes a data set called births, that simply lists out the total number of births per year:
```{r}
data(births)
ggplot(births, aes(year, births)) + geom_line()
```

Why are these last two graphs different? Because the first is counting names, the second is counting births. And most babies have names that are shared with other babies, especially in the same year. 